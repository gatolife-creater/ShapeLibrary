class Manager{static displayError(conditions){let message="ConditionalError: You must follow the following rules:";for(const condition of conditions)message+=`\n\t${condition}`;throw message}}class Point{constructor(x,y){this.x=x,this.y=y}static dist(p1,p2){return Math.sqrt((p2.x-p1.x)**2+(p2.y-p1.y)**2)}static getMidpoint(p1,p2){return new Point((p1.x+p2.x)/2,(p1.y+p2.y)/2)}static getSymmetricPoint(p,center){const x=center.x-p.x,y=center.y-p.y;return new Point(center.x+x,center.y+y)}static getBarycenter(p1,p2,p3){return new Point((p1.x+p2.x+p3.x)/3,(p1.y+p2.y+p3.y)/3)}static getCircumcenter(p1,p2,p3){const l1=new Line(p1,p2),l2=new Line(p2,p3),perpendicularBisector1=l1.getPerpendicularBisector(),perpendicularBisector2=l2.getPerpendicularBisector();return perpendicularBisector1.getIntersection(perpendicularBisector2)}static getOrthocenter(p1,p2,p3){const x1=p1.x,y1=p1.y,x2=p2.x,y2=p2.y,x3=p3.x,y3=p3.y,l1=new Linear(`${(y2-y1)/(x2-x1)}x+${-(y2-y1)/(x2-x1)+y1}`),l2=new Linear(`${(y3-y2)/(x3-x2)}x+${-(y3-y2)/(x3-x2)+y2}`),perpendicularLinear1=l1.getPerpendicularLinear(p3),perpendicularLinear2=l2.getPerpendicularLinear(p1);return perpendicularLinear1.getIntersection(perpendicularLinear2)}static getInnerCenter(p1,p2,p3){const A=p1,B=p2,C=p3,AB=new Line(A,B),BC=new Line(B,C),CA=new Line(C,A),P=BC.getDividingPoint(AB.getLength(),CA.getLength()),Q=CA.getDividingPoint(BC.getLength(),AB.getLength()),AP=new Line(A,P),BQ=new Line(B,Q);return AP.getIntersection(BQ)}static getExcenters(p1,p2,p3){const A=p1,B=p2,C=p3,BA=new Line(A,B),CB=new Line(B,C),AC=new Line(C,A),P=CB.getDividingPoint(BA.getLength(),-AC.getLength()),Q=BA.getDividingPoint(AC.getLength(),-CB.getLength()),R=AC.getDividingPoint(CB.getLength(),-BA.getLength()),AP=new Line(A,P),CQ=new Line(C,Q),BR=new Line(B,R);return[AP.getIntersection(CQ),CQ.getIntersection(BR),BR.getIntersection(AP)]}static estimateQuadraticByThreePoints(p1,p2,p3){const x1=p1.x,y1=p1.y,x2=p2.x,y2=p2.y,x3=p3.x,y3=p3.y,b=((y3-y1)*x2**2-(y3-y1)*x1**2-((y2-y1)*x3**2-(y2-y1)*x1**2))/((x2-x1)*(x1**2-x3**2)-(x3-x1)*(x1**2-x2**2)),a=(y2-y1-b*(x2-x1))/(x2**2-x1**2),c=y1-a*x1**2-b*x1;return new Quadratic(`${a}x^2+${b}x+${c}`)}magnify(center,magnification){const l1=new Line(center,this),p1=l1.getDividingPoint(-magnification,magnification-1);return new Point(p1.x,p1.y)}static O(){return new Point(0,0)}draw(){point(this.x,this.y)}}class Line{constructor(start,end){this.start=start,this.end=end}getMidpoint(){return Point.getMidpoint(this.start,this.end)}getInteriorPoint(m,n){return m<=0||n<=0?Manager.displayError(["m > 0","n > 0"]):new Point((this.start.x*n+this.end.x*m)/(m+n),(this.start.y*n+this.end.y*m)/(m+n))}getExteriorPoint(m,n){return m<=0||n<=0?Manager.displayError(["m > 0","n > 0"]):new Point((-this.start.x*n+this.end.x*m)/(m-n),(-this.start.y*n+this.end.y*m)/(m-n))}getDividingPoint(m,n){return new Point((this.start.x*n+this.end.x*m)/(m+n),(this.start.y*n+this.end.y*m)/(m+n))}getLength(){return Point.dist(this.start,this.end)}getDistBetweenPoint(p){const a=(this.end.y-this.start.y)/(this.end.x-this.start.x),b=-1,c=this.start.y-a*this.start.x;return a===1/0?Math.abs(this.start.x-p.x):Math.abs(a*p.x+b*p.y+c)/Math.sqrt(a**2+1)}getIntersection(l){const a=(l.end.y-l.start.y)/(l.end.x-l.start.x),b=l.start.y-(l.end.y-l.start.y)/(l.end.x-l.start.x)*l.start.x,c=(this.end.y-this.start.y)/(this.end.x-this.start.x),d=this.start.y-(this.end.y-this.start.y)/(this.end.x-this.start.x)*this.start.x;return a===c?new Point(NaN,NaN):a===1/0?new Point(l.start.x,c*l.start.x+d):c===1/0?new Point(this.start.x,a*this.start.x+b):new Point((d-b)/(a-c),a*(d-b)/(a-c)+b)}getIntersectionStrict(l){const x1=this.start.x,y1=this.start.y,x2=this.end.x,y2=this.end.y,x3=l.start.x,y3=l.start.y,x4=l.end.x,y4=l.end.y,a1=(y2-y1)/(x2-x1),a2=(y4-y3)/(x4-x3),x=(a1*x1-y1-a2*x3+y3)/(a1-a2),y=(y2-y1)/(x2-x1)*(x-x1)+y1;return Math.abs(a1)===Math.abs(a2)?new Point(NaN,NaN):x>Math.max(x1,x2)||x>Math.max(x3,x4)||y>Math.max(y1,y2)||y>Math.max(y3,y4)||x<Math.min(x1,x2)||x<Math.min(x3,x4)||x<Math.min(x1,x2)||y<Math.min(y3,y4)?new Point(NaN,NaN):new Point(x,y)}getPerpendicularBisector(){const x1=this.start.x,y1=this.start.y,x2=this.end.x,y2=this.end.y,linear=new Linear(`${(y2-y1)/(x2-x1)}x+${-(y2-y1)/(x2-x1)*x1+y1}`);return linear.getPerpendicularLinear(this.getMidpoint())}magnify(center,magnification){const l1=new Line(center,this.start),l2=new Line(center,this.end),p1=l1.getDividingPoint(-magnification,magnification-1),p2=l2.getDividingPoint(-magnification,magnification-1);return new Line(p1,p2)}draw(){line(this.start.x,this.start.y,this.end.x,this.end.y)}}class Triangle{constructor(p1,p2,p3){this.p1=p1,this.p2=p2,this.p3=p3,this.l1=new Line(this.p1,this.p2),this.l2=new Line(this.p2,this.p3),this.l3=new Line(this.p3,this.p1)}getBarycenter(){return Point.getBarycenter(this.p1,this.p2,this.p3)}getCircumcenter(){return Point.getCircumcenter(this.p1,this.p2,this.p3)}getCircumscribedCircle(){const circumcenter=this.getCircumcenter(),r=Point.dist(circumcenter,this.p1);return new Circle(circumcenter.x,circumcenter.y,r)}getOrthocenter(){return Point.getOrthocenter(this.p1,this.p2,this.p3)}getInnerCenter(){return Point.getInnerCenter(this.p1,this.p2,this.p3)}getInscribedCircle(){const innerCenter=this.getInnerCenter(),r=this.l1.getDistBetweenPoint(innerCenter);return new Circle(innerCenter.x,innerCenter.y,r)}getExcenters(){return Point.getExcenters(this.p1,this.p2,this.p3)}getAroundLength(){const p1=new Line(this.p1,this.p2),p2=new Line(this.p2,this.p3),p3=new Line(this.p3,this.p1);return p1.getLength()+p2.getLength()+p3.getLength()}getArea(){return.5*Math.abs((this.p1.x-this.p3.x)*(this.p2.y-this.p3.y)-(this.p2.x-this.p3.x)*(this.p1.y-this.p3.y))}getSymmetricTriangle(center){return new Triangle(Point.getSymmetricPoint(this.p1,center),Point.getSymmetricPoint(this.p2,center),Point.getSymmetricPoint(this.p3,center))}magnify(center,magnification){const l1=new Line(center,this.p1),l2=new Line(center,this.p2),l3=new Line(center,this.p3),p1=l1.getDividingPoint(-magnification,magnification-1),p2=l2.getDividingPoint(-magnification,magnification-1),p3=l3.getDividingPoint(-magnification,magnification-1);return new Triangle(p1,p2,p3)}draw(){triangle(this.p1.x,this.p1.y,this.p2.x,this.p2.y,this.p3.x,this.p3.y)}}class Quad{constructor(p1,p2,p3,p4){this.p1=p1,this.p2=p2,this.p3=p3,this.p4=p4,this.l1=new Line(this.p1,this.p2),this.l2=new Line(this.p2,this.p3),this.l3=new Line(this.p3,this.p4),this.l4=new Line(this.p4,this.p1)}getArea(){const triangle1=new Triangle(this.p1,this.p2,this.p3),triangle2=new Triangle(this.p2,this.p3,this.p4);return triangle1.getArea()+triangle2.getArea()}getAroundLength(){const l1=new Line(this.p1,this.p2),l2=new Line(this.p2,this.p3),l3=new Line(this.p3,this.p4),l4=new Line(this.p4,this.p1);return l1.getLength()+l2.getLength()+l3.getLength()+l4.getLength()}getSymmetricQuad(center){return new Quad(Point.getSymmetricPoint(this.p1,center),Point.getSymmetricPoint(this.p2,center),Point.getSymmetricPoint(this.p3,center),Point.getSymmetricPoint(this.p4,center))}magnify(center,magnification){const l1=new Line(center,this.p1),l2=new Line(center,this.p2),l3=new Line(center,this.p3),l4=new Line(center,this.p4),p1=l1.getDividingPoint(-magnification,magnification-1),p2=l2.getDividingPoint(-magnification,magnification-1),p3=l3.getDividingPoint(-magnification,magnification-1),p4=l4.getDividingPoint(-magnification,magnification-1);return new Quad(p1,p2,p3,p4)}draw(){beginShape(),vertex(this.p1.x,this.p1.y),vertex(this.p2.x,this.p2.y),vertex(this.p3.x,this.p3.y),vertex(this.p4.x,this.p4.y),endShape(CLOSE)}}class Polygon{constructor(points){this.points=points,this.lines=[];for(let i=0;i<this.points.length;i++)i<this.points.length-1?this.lines.push(new Line(this.points[i],this.points[i+1])):this.lines.push(new Line(this.points[i],this.points[0]))}getAroundLength(){let result=0;for(const line of this.lines)result+=line.getLength();return result}getSymmetricPolygon(center){const points=[];for(const point of this.points)points.push(Point.getSymmetricPoint(point,center));return new Polygon(points)}magnify(center,magnification){const magnifiedPoints=[];for(const point of this.points){const l=new Line(center,point),p=l.getDividingPoint(-magnification,magnification-1);magnifiedPoints.push(p)}return new Polygon(magnifiedPoints)}draw(){beginShape();for(const point of this.points)vertex(point.x,point.y);endShape(CLOSE)}}class Circle{constructor(x,y,r){this.x=x,this.y=y,this.center=new Point(x,y),this.r=r,this.d=2*r}getAround(){return 2*Math.PI*this.r}getArea(){return Math.PI*this.r**2}getSymmetricCircle(center){const p=this.center,{x:x,y:y}=Point.getSymmetricPoint(p,center);return new Circle(x,y,this.r)}getIntersectionsOfCL(linear){const a=this.center.x,b=this.center.y,c=linear.slope,d=linear.yIntercept,r=this.r,_a=c**2+1,_b=2*(c*d-b*c-a),_c=a**2+(d-b)**2-r**2,quadratic=new Quadratic(`${_a}x^2+${_b}x+${_c}`),solutions=quadratic.getIntersectionsOfQL(new Linear("0x+0")),y1=linear.getY(solutions[0].x),y2=linear.getY(solutions[1].x);return[new Point(solutions[0].x,y1),new Point(solutions[1].x,y2)]}getTangentLinear(p){const A=p.x**2/p.y**2+1,B=-2*p.x*this.r**2/p.y**2,C=this.r**2*(this.r**2-p.y**2)/p.y**2,quadratic=new Quadratic(`${A}x^2+${B}x+${C}`),points=quadratic.getSolution(),xt1=points[0].x,yt1=(this.r**2-p.x*xt1)/p.y,xt2=points[1].x,yt2=(this.r**2-p.x*xt2)/p.y,linears=[Linear.estimateLinearByTwoPoints(p,new Point(xt1,yt1)),Linear.estimateLinearByTwoPoints(p,new Point(xt2,yt2))];return linears}magnify(center,magnification){const l1=new Line(center,this.center),p=l1.getDividingPoint(-magnification,magnification-1);return new Circle(p.x,p.y,this.r*magnification)}draw(){circle(this.x,this.y,this.d)}}class Point3D{constructor(x,y,z){this.x=x,this.y=y,this.z=z}static dist(p1,p2){return Math.sqrt((p2.x-p1.x)**2+(p2.y-p1.y)**2+(p2.z-p1.z)**2)}static getMidpoint(p1,p2){return new Point3D((p1.x+p2.x)/2,(p1.y+p2.y)/2,(p1.z+p2.z)/2)}static getSymmetricPoint(p,center){const x=center.x-p.x,y=center.y-p.y,z=center.z-p.z;return new Point3D(center.x+x,center.y+y,center.z+z)}static getBarycenter(p1,p2,p3){return new Point3D((p1.x+p2.x+p3.x)/3,(p1.y+p2.y+p3.y)/3,(p1.z+p2.z+p3.z)/3)}magnify(center,magnification){const l1=new Line3D(center,this),p1=l1.getDividingPoint(-magnification,magnification-1);return new Point3D(p1.x,p1.y,p1.z)}static O(){return new Point3D(0,0,0)}draw(){point(this.x,this.y,this.z)}}class Line3D{constructor(start,end){this.start=start,this.end=end}getLength(){return Point3D.dist(this.start,this.end)}getMidpoint(){return Point3D.getMidpoint(this.start,this.end)}getInteriorPoint(m,n){return m<=0||n<=0?Manager.displayError(["m > 0","n > 0"]):new Point3D((this.start.x*n+this.end.x*m)/(m+n),(this.start.y*n+this.end.y*m)/(m+n),(this.start.z*n+this.end.z*m)/(m+n))}getExteriorPoint(m,n){return m<=0||n<=0?Manager.displayError(["m > 0","n > 0"]):new Point3D((-this.start.x*n+this.end.x*m)/(m-n),(-this.start.y*n+this.end.y*m)/(m-n),(-this.start.z*n+this.end.z*m)/(m-n))}getDividingPoint(m,n){return new Point3D((this.start.x*n+this.end.x*m)/(m+n),(this.start.y*n+this.end.y*m)/(m+n),(this.start.z*n+this.end.z*m)/(m+n))}magnify(center,magnification){const l1=new Line3D(center,this.start),l2=new Line3D(center,this.end),p1=l1.getDividingPoint(-magnification,magnification-1),p2=l2.getDividingPoint(-magnification,magnification-1);return new Line3D(p1,p2)}draw(){line(this.start.x,this.start.y,this.start.z,this.end.x,this.end.y,this.end.z)}}class Triangle3D{constructor(p1,p2,p3){this.p1=p1,this.p2=p2,this.p3=p3,this.l1=new Line3D(p1,p2),this.l2=new Line3D(p2,p3),this.l3=new Line3D(p3,p1)}getBarycenter(){return Point3D.getBarycenter(this.p1,this.p2,this.p3)}getAroundLength(){const p1=new Line3D(this.p1,this.p2),p2=new Line3D(this.p2,this.p3),p3=new Line3D(this.p3,this.p1);return p1.getLength()+p2.getLength()+p3.getLength()}getArea(){const a=this.l1.getLength(),b=this.l2.getLength(),c=this.l3.getLength(),s=(a+b+c)/2,S=Math.sqrt(s*(s-a)*(s-b)*(s-c));return S}getSymmetricTriangle(center){return new Triangle3D(Point3D.getSymmetricPoint(this.p1,center),Point3D.getSymmetricPoint(this.p2,center),Point3D.getSymmetricPoint(this.p3,center))}magnify(center,magnification){const l1=new Line3D(center,this.p1),l2=new Line3D(center,this.p2),l3=new Line3D(center,this.p3),p1=l1.getDividingPoint(-magnification,magnification-1),p2=l2.getDividingPoint(-magnification,magnification-1),p3=l3.getDividingPoint(-magnification,magnification-1);return new Triangle3D(p1,p2,p3)}draw(){beginShape(),vertex(this.p1.x,this.p1.y,this.p1.z),vertex(this.p2.x,this.p2.y,this.p2.z),vertex(this.p3.x,this.p3.y,this.p3.z),endShape(CLOSE)}}class Quad3D{constructor(p1,p2,p3,p4){this.p1=p1,this.p2=p2,this.p3=p3,this.p4=p4,this.l1=new Line3D(this.p1,this.p2),this.l2=new Line3D(this.p2,this.p3),this.l3=new Line3D(this.p3,this.p4),this.l4=new Line3D(this.p4,this.p1)}magnify(center,magnification){const l1=new Line3D(center,this.p1),l2=new Line3D(center,this.p2),l3=new Line3D(center,this.p3),l4=new Line3D(center,this.p4),p1=l1.getDividingPoint(-magnification,magnification-1),p2=l2.getDividingPoint(-magnification,magnification-1),p3=l3.getDividingPoint(-magnification,magnification-1),p4=l4.getDividingPoint(-magnification,magnification-1);return new Quad3D(p1,p2,p3,p4)}draw(){beginShape(),vertex(this.p1.x,this.p1.y,this.p1.z),vertex(this.p2.x,this.p2.y,this.p2.z),vertex(this.p3.x,this.p3.y,this.p3.z),vertex(this.p4.x,this.p4.y,this.p4.z),endShape(CLOSE)}}class Box{constructor(x,y,z,w,h,d){this.x=x,this.y=y,this.z=z,this.w=w,this.h=h,this.d=d}getSurfaceArea(){return 2*(this.w*this.h+this.h*this.d+this.d*this.w)}getVolume(){return this.w*this.h*this.d}magnify(center,magnification){const boxCenter=new Point3D(this.x+this.w/2,this.y+this.h/2,this.z+this.d/2),l1=new Line3D(center,boxCenter),p1=l1.getDividingPoint(-magnification,magnification-1),w=this.w*magnification,h=this.h*magnification,d=this.d*magnification,x=p1.x-w/2,y=p1.y-h/2,z=p1.z-d/2;return new Box(x,y,z,w,h,d)}draw(){push(),translate(this.x,this.y,this.z),box(this.w,this.h,this.d),pop()}}class Sphere{constructor(x,y,z,r){this.center=new Point3D(x,y,z),this.x=x,this.y=y,this.z=z,this.r=r}getSurfaceArea(){return 4*Math.PI*this.r**2}getVolume(){return 4*Math.PI*this.r**3/3}magnify(center,magnification){const l1=new Line3D(center,this.center),p1=l1.getDividingPoint(-magnification,magnification-1);return new Sphere(p1.x,p1.y,p1.z,this.r*magnification)}draw(){push(),translate(this.x,this.y,this.z),sphere(this.r),pop()}}class Linear{constructor(formula){this.setForms(formula),this.slope,this.yIntercept,this.vertexForm}setForms(formula){const array=formula.replace(/\s/g,"").split(/\+|x/).filter(v=>v);this.slope=Number(array[0]),this.yIntercept=Number(array[1]);const stringSlope=String(this.slope),stringYIntercept=this.yIntercept>=0?"+"+String(this.yIntercept):String(this.yIntercept);this.vertexForm=`${stringSlope}x${stringYIntercept}`}getY(x){return this.slope*x+this.yIntercept}getIntersection(linear){const a=this.slope,b=this.yIntercept,c=linear.slope,d=linear.yIntercept;return new Point((d-b)/(a-c),a*(d-b)/(a-c)+b)}getPerpendicularLinear(p){const a=this.slope,x1=p.x,y1=p.y;return new Linear(`${-1/a}x+${x1/a+y1}`)}getSymmetricPointToL(p){const perpendicularLinear=this.getPerpendicularLinear(p),center=this.getIntersection(perpendicularLinear),symmetricPoint=Point.getSymmetricPoint(p,center);return symmetricPoint}magnify(center,magnification){const l1=new Line(center,new Point(0,this.yIntercept)),l2=new Line(center,new Point(5,this.getY(5))),p1=l1.getDividingPoint(-magnification,magnification-1),p2=l2.getDividingPoint(-magnification,magnification-1);return Linear.estimateLinearByTwoPoints(p1,p2)}static estimateLinearByTwoPoints(p1,p2){const a=(p2.y-p1.y)/(p2.x-p1.x),b=p1.y-a*p1.x;return new Linear(`${a}x+${b}`)}draw(min,max){beginShape();for(let x=min;x<max;x++){const y=this.getY(x);vertex(x,y)}endShape()}}class Quadratic{constructor(formula){this.setForms(formula),this.a,this.b,this.c,this.p,this.q,this.vertexForm,this.standardForm}static judgeForm(formula){return formula.match(/x\^2/g)&&formula.match(/x/g)?"vertex":formula.match(/x/g)&&formula.match(/\(/g)&&formula.match(/\)/g)&&formula.match(/\^2/g)?"standard":Manager.displayError(["You MUST use following:","x","(",")","^2"])}setForms(formula){if("vertex"===Quadratic.judgeForm(formula)){const array=formula.replace(/\s/g,"").split(/\+|x\^2|x/).filter(v=>v);this.a=Number(array[0]),this.b=Number(array[1]),this.c=Number(array[2]);const stringA=String(this.a),stringB=this.b>=0?"+"+String(this.b):String(this.b),stringC=this.c>=0?"+"+String(this.c):String(this.c);this.vertexForm=`${stringA}x^2${stringB}x${stringC}`,this.p=-this.b/(2*this.a),this.q=-(this.b**2-4*this.a*this.c)/(4*this.a);const stringP=-1*this.p>=0?"+"+String(-1*this.p):String(-1*this.p),stringQ=this.q>=0?"+"+String(this.q):String(this.q);this.standardForm=`${stringA}(x${stringP})^2${stringQ}`}else if("standard"===Quadratic.judgeForm(formula)){const array=formula.replace(/\s/g,"").split(/\(|\)|\+|x|\^2/).filter(v=>v);this.a=Number(array[0]),this.p=-1*Number(array[1]),this.q=Number(array[2]);const stringA=String(this.a),stringP=-1*this.p>=0?"+"+String(-1*this.p):String(-1*this.p),stringQ=this.q>=0?"+"+String(this.q):String(this.q);this.standardForm=`${stringA}(x${stringP})^2${stringQ}`,this.b=-2*this.a*this.p,this.c=this.a*this.p**2+this.q;const stringB=this.b>=0?"+"+String(this.b):String(this.b),stringC=this.c>=0?"+"+String(this.c):String(this.c);this.vertexForm=`${stringA}x^2${stringB}x${stringC}`}}getVertex(){return new Point(this.p,this.q)}getY(x){return this.a*x**2+this.b*x+this.c}getYIntercept(){return new Point(0,this.getY(0))}getSymmetricQuadratic(center){const a=-this.a,p=-Point.getSymmetricPoint(this.getVertex(),center).x,q=Point.getSymmetricPoint(this.getVertex(),center).y;return new Quadratic(`${a}(x +${p})^2 + ${q}`)}getSymmetricQuadraticToX_Axis(){return new Quadratic(`${-this.a}x^2+${-this.b}x+${-this.c}`)}getSymmetricQuadraticToY_Axis(){return new Quadratic(`${this.a}x^2+${-this.b}x+${this.c}`)}getIntersectionsOfQL(linear){const a=this.a,b=this.b,c=this.c,d=linear.slope,e=linear.yIntercept,x1=(d-b+Math.sqrt((b-d)**2-4*a*(c-e)))/(2*a),y1=d*x1+e,x2=(d-b-Math.sqrt((b-d)**2-4*a*(c-e)))/(2*a),y2=d*x2+e;return[new Point(x1,y1),new Point(x2,y2)]}getIntersectionsOfQQ(quadratic){const a=this.a,b=this.b,c=this.c,d=quadratic.a,e=quadratic.b,f=quadratic.c;if(a===d){const x=(f-c)/(b-e),y=a*x**2+b*x+c;return[new Point(x,y),new Point(NaN,NaN)]}{const x1=(e-b+Math.sqrt((b-e)**2-4*(a-d)*(c-f)))/(2*(a-d)),y1=a*x1**2+b*x1+c,x2=(e-b-Math.sqrt((b-e)**2-4*(a-d)*(c-f)))/(2*(a-d)),y2=a*x2**2+b*x2+c;return[new Point(x1,y1),new Point(x2,y2)]}}getTangentLinear(x){const a=this.a,b=this.b,c=this.c,d=2*a*x+b,e=(2*b*d+4*a*c-b**2-d**2)/(4*a);return new Linear(`${d}x+${e}`)}getNormalLinear(x){const l=this.differentiate();return new Linear(`${-1/l.getY(x)}x+${x/l.getY(x)+this.getY(x)}`)}getSolution(){return this.getIntersectionsOfQL(new Linear("0x+0"))}magnify(center,magnification){const l1=new Line(center,this.getYIntercept()),l2=new Line(center,new Point(-5,this.getY(-5))),l3=new Line(center,new Point(5,this.getY(5))),p1=l1.getDividingPoint(-magnification,magnification-1),p2=l2.getDividingPoint(-magnification,magnification-1),p3=l3.getDividingPoint(-magnification,magnification-1);return Quadratic.estimateQuadraticByThreePoints(p1,p2,p3)}moveQuadratic(x,y){const newP=-(this.p+x),newQ=this.q+y;return new Quadratic(`${this.a}(x+${newP})^2+${newQ}`)}static estimateQuadraticByAandTwoPoints(a,p1,p2){const x1=p1.x,y1=p1.y,x2=p2.x,y2=p2.y,b=(y2-y1-a*(x2**2-x1**2))/(x2-x1),c=y1-a*x1**2-b*x1**2;return new Quadratic(`${a}x^2+${b}x+${c}`)}static estimateQuadraticByThreePoints(p1,p2,p3){return Point.estimateQuadraticByThreePoints(p1,p2,p3)}differentiate(){return new Linear(`${2*this.a}x+${this.b}`)}draw(min,max){beginShape();for(let x=min;x<max;x++){const y=this.getY(x);vertex(x,y)}endShape()}}